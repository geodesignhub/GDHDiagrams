/**
   *
   * @param {PortalGroup} portalGroup
   */
  initializeGroupLayers({portalGroup}) {

    // FIND GROUP LAYERS //
    const groupLayersList = document.getElementById('group-layers-list');
    if (portalGroup) {

      // ASK PORTAL GROUP TO RETURN PORTAL ITEMS //
      portalGroup.queryItems().then(({results}) => {

        // LAYER PORTAL ITEMS //
        const layerPortalItems = results.filter(item => item.isLayer);

        // LAYER LIST ITEMS //
        const layerListItems = layerPortalItems.map(this.createLayerListItem.bind(this));

        // ADD LAYER LIST ITEMS //
        groupLayersList.replaceChildren(...layerListItems);
      });

    } else {
      groupLayersList.replaceChildren();
    }
  }

   /**
     *
     * @param {Portal} portal
     */
    /*initializeGroupSelection({portal}) {

      // FIND GROUP //
      const groupsList = document.getElementById('groups-list');
      groupsList.addEventListener('calciteListChange', ({detail}) => {
        // GROUP ID //
        const groupId = detail.keys().next().value;

        // ASK PORTAL TO FIND GROUP //
        portal.queryGroups({query: `id: ${ groupId }`}).then(({results}) => {

          // CLEAR MAP LAYERS //
          this.dispatchEvent(new CustomEvent('layers-clear', {detail: {}}));

          // LIST THE GROUP LAYERS //
          this.initializeGroupLayers({portalGroup: results[0]});

        });
      });

    }*/


/**
   *
   * @param {MapView} view
   */
  initializeSketchTools({view}) {
    require([
      'esri/core/reactiveUtils',
      'esri/layers/GraphicsLayer',
      "esri/widgets/Expand",
      'esri/widgets/Sketch'
    ], (reactiveUtils, GraphicsLayer, Expand, Sketch) => {

      // SKETCH LAYER //
      const sketchLayer = new GraphicsLayer({listMode: 'hide'});
      view.map.add(sketchLayer);

      // SKETCH //
      const sketch = new Sketch({
        view,
        layer: sketchLayer,
        creationMode: 'single',
        availableCreateTools: ['polygon', 'rectangle', 'circle'],
        defaultCreateOptions: {mode: 'hybrid'},
        visibleElements: {
          selectionTools: {
            "rectangle-selection": false,
            "lasso-selection": false
          }
        }
      });

      // WHEN A NEW SKETCH HAS BEEN CREATED //
      sketch.on("create", (event) => {
        if (event.state === "complete") {
          this.dispatchEvent(new CustomEvent('analysis-geometry', {detail: {geometry: event.graphic.geometry}}));
        }
      });

      // SKETCH EXPAND //
      const sketchExpand = new Expand({view, content: sketch});
      view.ui.add(sketchExpand, {position: 'top-right', index: 0});

    });
  }


 /*this.addEventListener('analysis-geometry', ({detail: {geometry}}) => {
     if (analysisLayer) {
     view.whenLayerView(analysisLayer).then(analysisLayerView => {

     const analysisQuery = analysisLayerView.createQuery();
     analysisQuery.set({
     where: `1=1`,
     geometry
     });

     analysisLayerView.queryFeatures(analysisQuery).then(analysisFS => {
     // SELECTED FEATURES //
     const selectedFeatures = analysisFS.features;

     //
     // DO SOMETHING WITH SELECTED FEATURES //
     //
     view.popup.open({features: selectedFeatures});

     });
     });
     }
     });*/

// SEARCH //
          // const search = new Search({view});
          // const searchExpand = new Expand({view, content: search});
          // view.ui.add(searchExpand, {position: 'top-left', index: 0});

          // HOME //
          // const home = new Home({view});
          // view.ui.add(home, {position: 'top-left', index: 1});

          /*
           const fullExtentAction = {
           id: "full-extent",
           type: 'button',
           title: "Go to full extent",
           className: "esri-icon-zoom-out-fixed"
           };
           */

          /*
           const blendModeAction = {
           id: "blend-mode",
           type: 'toggle',
           value: false,
           title: "Blend Mode: multiply"
           };
           */

          // LAYER LIST //
          /*
           const layerList = new LayerList({
           container: 'layer-list-container',
           view: view,
           visibleElements: {statusIndicators: true},
           listItemCreatedFunction: ({item}) => {

           const slider = new Slider({
           min: 0, max: 1, precision: 2, values: [item.layer.opacity],
           visibleElements: {labels: false, rangeLabels: true}
           });
           slider.on("thumb-drag", (event) => {
           item.layer.opacity = event.value;
           });

           const itemActions = [
           {...blendModeAction, value: (item.layer.blendMode === 'multiply')}
           ];
           if (item.layer.type !== 'group') {
           itemActions.push(fullExtentAction);
           }

           item.set({
           open: true,
           actionsOpen: true,
           panel: {
           open: true,
           title: 'opacity',
           className: "esri-icon-experimental",
           content: slider
           },
           actionsSections: [itemActions]
           });
           }
           });
           */

          /*layerList.on("trigger-action", (evt) => {
           const id = evt.action.id;
           if (id === "full-extent") {
           view.goTo(evt.item.layer.fullExtent.clone().expand(1.1));
           }
           if (id === "blend-mode") {
           evt.item.layer.blendMode = evt.action.value ? 'multiply' : 'normal';
           }
           });*/

 /**
 * based on: https://stackoverflow.com/questions/105034/how-do-i-create-a-guid-uuid
 *
 * @returns {string}
 */
function _uuid() {
  const url = URL.createObjectURL(new Blob());
  const [id] = url.toString().split('/').reverse();
  URL.revokeObjectURL(url);
  return id.replace(/-/g, '');
}

 /**
 * GET DIAGRAM COLOR BASED ON CURRENT RENDERER
 *
 * @param diagramAttributes
 * @returns {Promise<unknown>}
 * @private
 */
/*const _getDiagramColor = ({diagramAttributes}) => {
 return new Promise((resolve, reject) => {
 symbolUtils.getDisplayedColor({attributes: diagramAttributes}, {renderer: interventionsLayer.renderer}).then((color) => {
 resolve({color});
 });
 });
 };*/

 // GET COLOR USED IN GEOPLANNER FOR THIS FEATURE //
 // _getDiagramColor({diagramAttributes: diagramAttributes}).then(({color}) => {
 //   diagramItem.style.borderLeftColor = color.toCss();
 // });

 //
 // GET THE LAYER FROM THE PORTAL ITEM //
 //
 // - THIS WILL INSTANTIATE A FEATURE LAYER BASED ON THE PORTAL ITEM
 // Layer.fromPortalItem(firstLayerPortalItem).then((layer) => {
 // THE GEOPLANNER LAYER ITEM REFERENCES A FEATURE LAYER WITH MULTIPLE SUBLAYERS
 // SO WE GET BACK A GROUP LAYER WITH TWO FEATURE LAYERS
 // AND WE THEN MAKE SURE ALL SUB LAYERS ARE LOADED...
 // layer.loadAll().then(() => {

 // INTERVENTIONS LAYER //
 //  - hardocded to find a layer with a title that includes 'interventions'...
 //  - TODO: FIND BETTER WAY TO HANDLE THIS...
 // const interventionsLayer = layer.layers.find(l => l.title.toLowerCase().includes('interventions'));

 // DISPLAY FILTER USED OF THE GEOPLANNER DESIGN LAYER //
 // - THIS WILL SHOW THE DEFAULT QUERY USED FOR THIS LAYER
 //   AND SHOWS THE ID OF THE GEOPLANNER PROJECT AND DESIGN
 // geoplannerSourceItemDetails.innerHTML = interventionsLayer.definitionExpression;

 //
 //  IMPORTANT: createQuery() WILL USE THE LAYER DEFINITION EXPRESSION WHICH PROVIDES A SCENARIO SPECIFIC FILTER
 //    - WE WANT THE GEOMETRY AND ALL THE FIELDS SO WE CAN REPLICATE THEM WHEN ADDING AS NEW DESIGN/PLAN...
 //
 // const analysisQuery = interventionsLayer.createQuery();

 // DIAGRAMS FILTER //
 //  - IN ADDITION TO THE DEFAULT FILTER WE ALSO IGNORE ANY FEATURE WITHOUT AN INTERVENTION
 //  - NOTE: ALSO USED WHEN RETRIEVING THE GEOJSON FEATURES...
 // const diagramsFilter = `${ analysisQuery.where } AND (Intervention_System <> 'NA')`;  // TODO: REPLACE 'NA' WITH NULL VALUES?

 // SET ANALYSIS QUERY PARAMETERS //
 //  - UPDATE THE WHERE CLAUSE TO ONLY INCLUDE FEATURES WITH AN INTERVENTION
 /*analysisQuery.set({
  where: diagramsFilter,
  outFields: ['*'],
  returnGeometry: true
  });*/

//
// GET THE FEATURES FROM THE FEATURE LAYER //
// BREAK DOWN THE LIST OF FEATURES BY SYSTEM TO PRODUCE A LIST OF DIAGRAMS
//
// interventionsLayer.queryFeatures(analysisQuery).then(analysisFS => {
//   console.info("Esri JSON features via queryFeatures(): ", analysisFS);

//
// DIAGRAM FEATURES ORGANIZED BY SYSTEM //
//
// const diagramBySystems = _displayFeaturesList(gdhFeaturesList, analysisFS.features);
// console.info("Diagrams by System as Esri JSON: ", diagramBySystems);
